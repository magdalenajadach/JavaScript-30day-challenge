<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
</head>
<body>

  <script>

    // ARRAYS
    // start with strings, numbers and booleans

    let age = 100;
    let age2 = age;

    console.log(age, age2); print 100, 100
    age = 200;
    console.log(age, age2); print 200, 100

    // arrays
    const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];
    const team = players;
    console.log(players, team); // same values

    team[3] = 'Lux';
    console.log(players, team) // same values - it's a reference, so we updating also the first array

    // make a copy of an array then a reference
    const team3 = players.slice();
    const team4 = [].concat(players);

    // the new ES6 spread
    const team5 = [...players];

    // Array.from();
    const team6 = Array.from(players);

    // OBJECTS

    const person = {
        name: 'Magda Jadach',
        age: 99
    };

    const captain = person;
    captain.number = 13;

    console.log(person); //=> {name: 'Magda Jadach', age: 99, number: 13} because it's reference;

    // let's make a copy them instead of reference:
    // use Object.assign(emptyObject, objectWeWantCopy, propertyWeWantToAdd)
    const cap2 = Object.assign({}, person, { number: 99, age: 13 });

    // WARNING: only one level deep - doesn't work for nested pbjects
    
    // hack for deep cloninng
    const magda = {
        name: 'Magda',
        age: 30,
        social: {
            twitter: @magda_jadach
        }
    };
    const mag2 = JSON.parse(JSON.stringify(magda));
    
  </script>

</body>
</html>